# -*- coding: utf-8 -*-
"""OOP_Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-ZUtuqlNBF3dMJTWoVNxA9mVxFNHDFSe
"""

# Object oriented in python - classes, objects ,
# inheritance, abstract classes, etc

import math

class Complex:

  cname = 'Complex' # class variable

  def __init__(self,x,y): 
    # x and y are the instance variables for the class
    self.x=x
    self.y=y

  def magnitude(self):
    return math.sqrt(self.x**2 + self.y**2)

  def display(self):
    print(str(self.x)+'+'+str(self.y)+'i')

  def add(self,c):
    self.x = self.x + c.x
    self.y = self.y + c.y

  @classmethod # class methods - belonging to class
  def datatype(cls):
    return cls.cname

  # static methods - nothing to do with instances/class , extra fxn
  @staticmethod
  def summary(): # no parameter is passes
    print('Complex class has two instance variables x and y')

c1=Complex(4,5)
c2=Complex(3,8)

Complex.display(c1) # passing object into method as parameter
c2.display() # using object itself to call method

c1.add(c2)
c1.display()

print(Complex.datatype())
Complex.summary()

# class inside a class

class Student:

  def __init__(self,name,roll):
    self.name=name
    self.roll=roll
    self.lap = self.Laptop() # Laptop object associated with Student class

  def show(self):
    print(self.name , self.roll)
    self.lap.show();

  # inner class - object of inner class can be used as attribute of outer class
  class Laptop:

    def __init__(self):
      self.brand = 'HP'
      self.cpu = 'i7'

    def show(self):
      print(self.brand, self.cpu)

s1 = Student('Rohit',45)
s2 = Student('Pawan',52)

lap1 = s1.lap
lap2 = s2.lap

print(id(lap1))
print(id(lap2))

s1.show()
s2.show()

# Inheritance 

class Base:

  def func1(self):
    print('func1 of Base class')

  def func2(self):
    print('func2 of Base class')

class Derv(Base):

  def func3(self):
    print('func3 of Derv class')

  def func4(self):
    print('func4 of Derv class')

class MultDerv(Derv,Base): # order of declaring the inherited classes - MRO

  # inherits both Base and Derv classes

  def func5(self):
    print('func5 of multderv class')

b = Base()

b.func1()
b.func2()

d = Derv()

d.func2()
d.func4()

md = MultDerv()

md.func1()
md.func3()
md.func5()

# constructors in inheritance -> super()

'''
if there is no constructor in Derv class,when object of Derv class is created
it will call __init__() of Base class,
But if constructor is defined for Derv that will be called.

What if we need to invoke super class constructor also ??
'''

class Base:

  def __init__(self):
    print('base init')

  def fxn1(self):
    print('fxn1 base')


class Derv(Base):

  def __init__(self):
    super().__init__() # invokes superclass i.e. Base class constructor
    print('derv init')
    
  def fxn2(self):
    print('fxn2 derv')

ob = Base()
ob.fxn1()

print('\n')

ob = Derv()
ob.fxn1()
ob.fxn2()

'''
MRO : Method Resolution Order
- for a class inheriting from multiple classes, order or preference regarding
  which super().__init__() to call is done from LEFT to RIGHT 
'''

class Base2:
  
  def __init__(self):
    print('base2 init')

  def fxn1(self):
    print('fxn1 Base2')
  
class Third(Base,Base2): # here ordering is Base > Base2

  def __init__(self):
    super().__init__()    # Base init will be called and NOT Base2 init
    print('third init')

  def fxn4(self):
    print('fxn4 third')

ob = Third()

ob.fxn1() # here the method from Base class is called as order is Base > Base2
ob.fxn4()

# Polymorphism
'''
- method overloading is NOT available in Python
- method overriding is available, however
'''

class A:
  
  def show(self):
    print('A show')

class B(A):
  
  def show(self):
    print('B show')

ob = B()

ob.show() # B.show() if show() is present in B, else A.show() is called

# Abstract classes

'''
- python does not support abstract classes 
- but we can make it do so using the ABC module
'''

from abc import ABC, abstractmethod

# Abstract method - a method without a body (using 'pass' keyword)
# Abstract class - class having atleast one abstract method
# - we cannot instantiate an abstract class
# - abstract class is mainly required to fulfil OOP design pattern

class Computer(ABC):
  @abstractmethod
  def process(self):
    pass

class Laptop(Computer):
  def process(self):
    print('laptop process')

class Whiteboard(Computer):
  def process(self):
    print('writing')

class Programmer:
  def work(self,com):
    print('debugging and lyadh')
    com.process()

com1 = Laptop()
whtb = Whiteboard()
prog1 = Programmer()

prog1.work(com1)

prog1.work(whtb)

